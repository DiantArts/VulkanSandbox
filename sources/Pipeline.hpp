#pragma once

namespace vksb { class Window; }
namespace vksb { class Device; }

namespace vksb {

///////////////////////////////////////////////////////////////////////////
/// \brief Pipeline wrapper for GLFW
/// \ingroup vulkan
///
/// \include Pipeline.hpp <Pipeline.hpp>
///
///////////////////////////////////////////////////////////////////////////
class Pipeline {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // static elements
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Contains the size of the window
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Configuration {
        Configuration(
            ::std::size_t width,
            ::std::size_t height
        );
        ::VkViewport viewport{};
        ::VkRect2D scissor{};
        ::VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo{};
        ::VkPipelineRasterizationStateCreateInfo rasterizationInfo{};
        ::VkPipelineMultisampleStateCreateInfo multisampleInfo{};
        ::VkPipelineColorBlendAttachmentState colorBlendAttachment{};
        ::VkPipelineColorBlendStateCreateInfo colorBlendInfo{};
        ::VkPipelineDepthStencilStateCreateInfo depthStencilInfo{};
        ::VkPipelineLayout pipelineLayout{ nullptr };
        ::VkRenderPass renderPass{ nullptr };
        ::std::uint32_t subpass{ 0 };
    };



public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Pipeline(
        ::vksb::Device& device,
        const Pipeline::Configuration& configuration,
        ::std::string_view shaderFilenames
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~Pipeline();

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Pipeline(
        const Pipeline&
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const Pipeline&
    ) noexcept
        -> Pipeline& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Pipeline(
        Pipeline&&
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        Pipeline&&
    ) noexcept
        -> Pipeline& = delete;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Vulkan stuff
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    void bind(
        ::VkCommandBuffer commandBuffer
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the vulkan device
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getDevice()
        -> ::vksb::Device&;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helpers
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief TODO
    ///
    /// Puts the content of the file in a vector of char.
    ///
    /// TODO: What is a shader module
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto createShaderModule(
        const ::std::string& filepath,
        ::VkShaderModule& shaderModule
    ) -> bool;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Static member variables
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    static inline constexpr const auto shadersDirectory{ "./Shader/"sv };
    static inline constexpr const auto fragmentDirectory{ "Fragment/"sv };
    static inline constexpr const auto fragmentExtension{ ".spv"sv };
    static inline constexpr const auto vertexDirectory{ "Vertex/"sv };
    static inline constexpr const auto vertexExtension{ ".spv"sv };



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Member variables
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ::vksb::Device& m_device;
    ::VkPipeline m_graphicsPipeline;

    ::VkShaderModule m_vertexShaderModule;
    ::VkShaderModule m_fragmentShaderModule;

};

} // namespace vksb
