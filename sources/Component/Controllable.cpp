#include <pch.hpp>
#include <Component/Controllable.hpp>
#include <Component/Transformable.hpp>
#include <Configuration.hpp>


// ------------------------------------------------------------------ *structors

///////////////////////////////////////////////////////////////////////////
::vksb::component::Controllable::Controllable(
    bool ableToFly
)
    : m_ableToFly{ ableToFly }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Speed
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::getSpeed() const
    -> float
{
    return m_moveSpeed;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::setSpeed(
    float speed
)
{
    m_moveSpeed = speed;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Update
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::updatePosition(
    float deltaTime,
    ::vksb::component::Transformable& transformable
)
{
    if (m_ableToFly) {
        this->updateFly(deltaTime, transformable);
    } else {
        this->updateRun(deltaTime, transformable);
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Start moving
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::startMovingForward()
{
    m_movementState[Controllable::MovementState::forward] = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::startMovingBackward()
{
    m_movementState[Controllable::MovementState::backward] = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::startMovingRight()
{
    m_movementState[Controllable::MovementState::right] = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::startMovingLeft()
{
    m_movementState[Controllable::MovementState::left] = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::startMovingUp()
{
    m_movementState[Controllable::MovementState::up] = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::startMovingDown()
{
    m_movementState[Controllable::MovementState::down] = true;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Stop moving
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMovingForward()
{
    m_movementState[Controllable::MovementState::forward] = false;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMovingBackward()
{
    m_movementState[Controllable::MovementState::backward] = false;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMovingRight()
{
    m_movementState[Controllable::MovementState::right] = false;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMovingLeft()
{
    m_movementState[Controllable::MovementState::left] = false;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMovingUp()
{
    m_movementState[Controllable::MovementState::up] = false;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMovingDown()
{
    m_movementState[Controllable::MovementState::down] = false;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::stopMoving()
{
    m_movementState.reset();
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::immobilize()
{
    m_movementState.reset();
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Check if moving
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::isMovingForward() const
    -> bool
{
    return m_movementState.test(Controllable::MovementState::forward);
}

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::isMovingBackward() const
    -> bool
{
    return m_movementState.test(Controllable::MovementState::backward);
}

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::isMovingRight() const
    -> bool
{
    return m_movementState.test(Controllable::MovementState::right);
}

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::isMovingLeft() const
    -> bool
{
    return m_movementState.test(Controllable::MovementState::left);
}

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::isMovingUp() const
    -> bool
{
    return m_movementState.test(Controllable::MovementState::up);
}

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Controllable::isMovingDown() const
    -> bool
{
    return m_movementState.test(Controllable::MovementState::down);
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rotation
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::performRotation(
    ::vksb::component::Transformable& transformable
)
{
    while (::vksb::configuration.rotateSpeed.x >= 360) {
        ::vksb::configuration.rotateSpeed.x -= 360;
    }
    transformable.rotate(::std::move(::vksb::configuration.rotateSpeed));
    ::vksb::configuration.rotateSpeed = ::glm::vec3{ 0.0F, 0.0F, 0.0F };
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::rotate(
    const ::glm::vec2& offset
)
{
    ::vksb::configuration.rotateSpeed.x += offset.x * ::vksb::configuration.mouseSensitivity.x;
    ::vksb::configuration.rotateSpeed.y += offset.y * ::vksb::configuration.mouseSensitivity.y;

    if (::vksb::configuration.rotateSpeed.y > ::vksb::configuration.maxPitch) {
        ::vksb::configuration.rotateSpeed.y = ::vksb::configuration.maxPitch;
    } else if (::vksb::configuration.rotateSpeed.y < ::vksb::configuration.minPitch) {
        ::vksb::configuration.rotateSpeed.y = ::vksb::configuration.minPitch;
    }
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::rotate(
    const float yawOffset,
    const float pitchOffset
)
{
    ::vksb::configuration.rotateSpeed.x += yawOffset * ::vksb::configuration.mouseSensitivity.x;
    ::vksb::configuration.rotateSpeed.y += pitchOffset * ::vksb::configuration.mouseSensitivity.y;

    if (::vksb::configuration.rotateSpeed.y > ::vksb::configuration.maxPitch) {
        ::vksb::configuration.rotateSpeed.y = ::vksb::configuration.maxPitch;
    } else if (::vksb::configuration.rotateSpeed.y < ::vksb::configuration.minPitch) {
        ::vksb::configuration.rotateSpeed.y = ::vksb::configuration.minPitch;
    }
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::rotateYaw(
    const float offset
)
{
    ::vksb::configuration.rotateSpeed.x += offset * ::vksb::configuration.mouseSensitivity.x;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::rotatePitch(
    const float offset
)
{
    ::vksb::configuration.rotateSpeed.y += offset * ::vksb::configuration.mouseSensitivity.y;

    if (::vksb::configuration.rotateSpeed.y > ::vksb::configuration.maxPitch) {
        ::vksb::configuration.rotateSpeed.y = ::vksb::configuration.maxPitch;
    } else if (::vksb::configuration.rotateSpeed.y < ::vksb::configuration.minPitch) {
        ::vksb::configuration.rotateSpeed.y = ::vksb::configuration.minPitch;
    }
}

///////////////////////////////////////////////////////////////////////////
[[ nodiscard ]] auto ::vksb::component::Controllable::getRotation() const
    -> const ::glm::vec3&
{
    return ::vksb::configuration.rotateSpeed;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Helpers
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::updateFly(
    float deltaTime,
    ::vksb::component::Transformable& transformable
)
{
    // search the number of directions moving in and removing speed when multiple direction at once
    auto speedDirectionDivider{ 2 };
    if (this->isMovingForward() || this->isMovingBackward()) {
        speedDirectionDivider /= 2;
    }
    if (this->isMovingLeft() || this->isMovingRight()) {

        speedDirectionDivider /= 2;
    }
    if (this->isMovingUp() || this->isMovingDown()) {
        speedDirectionDivider /= 2;
    }
    if (speedDirectionDivider == 2) {
        return; // not any direction
    }

    auto velocity{ this->getSpeed() * deltaTime / speedDirectionDivider };
    if (this->isMovingForward()) {
        transformable.moveForward(velocity);
    } else if (this->isMovingBackward()) {
        transformable.moveBackward(velocity);
    } else if (this->isMovingLeft()) {
        transformable.moveLeft(velocity);
    } else if (this->isMovingRight()) {
        transformable.moveRight(velocity);
    } else if (this->isMovingUp()) {
        transformable.moveUp(velocity);
    } else if (this->isMovingDown()) {
        transformable.moveDown(velocity);
    }
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Controllable::updateRun(
    float deltaTime,
    ::vksb::component::Transformable& transformable
)
{
}
