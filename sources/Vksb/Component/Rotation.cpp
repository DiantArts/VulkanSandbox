#include <pch.hpp>
#include <Vksb/Component/Rotation.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////
::vksb::component::Rotation::Rotation() = default;

///////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////
::vksb::component::Rotation::Rotation(
    ::glm::vec3 offset
)
{
    this->setRotation(::std::move(offset));
}

///////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////
::vksb::component::Rotation::Rotation(
    float rotationXOffset,
    float rotationYOffset,
    float rotationZOffset
)
{
    this->rotate(rotationXOffset, rotationYOffset, rotationZOffset);
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rotation
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::rotate(
    const ::glm::vec3& offset
)
{
    if (offset.x) {
        this->rotateX(offset.x);
    }
    if (offset.y) {
        this->rotateY(offset.y);
    }
    if (offset.z) {
        this->rotateZ(offset.z);
    }
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::rotate(
    const float rotationXOffset,
    const float rotationYOffset,
    const float rotationZOffset
)
{
    if (rotationXOffset) {
        this->rotateX(rotationXOffset);
    }
    if (rotationYOffset) {
        this->rotateY(rotationYOffset);
    }
    if (rotationZOffset) {
        this->rotateZ(rotationZOffset);
    }
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::rotateX(
    const float offset
)
{
    m_rotation.x += offset;
    while (m_rotation.x >= 360) {
        m_rotation.x -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::rotateY(
    const float offset
)
{
    m_rotation.y += offset;
    while (m_rotation.y >= 360) {
        m_rotation.y -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::rotateZ(
    const float offset
)
{
    m_rotation.z += offset;
    while (m_rotation.z >= 360) {
        m_rotation.z -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::setRotation(
    ::glm::vec3 rotation
)
{
    m_rotation = ::std::move(rotation);
    while (m_rotation.x >= 360) {
        m_rotation.x -= 360;
    }
    while (m_rotation.y >= 360) {
        m_rotation.y -= 360;
    }
    while (m_rotation.z >= 360) {
        m_rotation.z -= 360;
    }
    m_isChanged = true;
}


///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::setRotation(
    const float rotationX,
    const float rotationY,
    const float rotationZ
)
{
    m_rotation = ::glm::vec3{ rotationX, rotationY, rotationZ };
    while (m_rotation.x >= 360) {
        m_rotation.x -= 360;
    }
    while (m_rotation.y >= 360) {
        m_rotation.y -= 360;
    }
    while (m_rotation.z >= 360) {
        m_rotation.z -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::setRotationX(
    const float rotationX
)
{
    m_rotation.x = rotationX;
    while (m_rotation.x >= 360) {
        m_rotation.x -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::setRotationY(
    const float rotationY
)
{
    m_rotation.y = rotationY;
    while (m_rotation.y >= 360) {
        m_rotation.y -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::setRotationZ(
    const float rotationZ
)
{
    m_rotation.y = rotationZ;
    while (m_rotation.z >= 360) {
        m_rotation.z -= 360;
    }
    m_isChanged = true;
}

///////////////////////////////////////////////////////////////////////////
[[ nodiscard ]] auto ::vksb::component::Rotation::getRotation() const
    -> const ::glm::vec3&
{
    return m_rotation;
}

///////////////////////////////////////////////////////////////////////////
[[ nodiscard ]] ::vksb::component::Rotation::operator const ::glm::vec3&() const
{
    return m_rotation;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Direction
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::updateDirection()
{
    m_direction = ::glm::normalize(::glm::vec3(
        cos(::glm::radians(m_rotation.x)) * cos(::glm::radians(m_rotation.y)),
        sin(::glm::radians(m_rotation.y)),
        sin(::glm::radians(m_rotation.x)) * cos(::glm::radians(m_rotation.y))
    ));
}

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Rotation::getDirection() const
    -> const ::glm::vec3&
{
    return m_direction;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Others
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::vksb::component::Rotation::isChanged() const
    -> bool
{
    return m_isChanged;
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::component::Rotation::resetChangedFlag()
{
    m_isChanged = false;
}
