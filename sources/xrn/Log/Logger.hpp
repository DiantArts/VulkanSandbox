#pragma once

namespace xrn {

///////////////////////////////////////////////////////////////////////////
/// \brief Contains a function
///
/// \include Logger.hpp <Logger.hpp>
///
/// Output varies if NDEBUG (no debug) that disable tests and PRINT_DEBUG
/// that prints "success" if the test succeeded.
/// The logger level is optional;
/// The print format is the same as fmt (::std::format) library
///
/// \code cpp
/// ::xrn::test(true, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::none, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::success, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::note, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::info, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::trace, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::debug, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::warning, "Message");
/// ::xrn::test(true, ::xrn::Logger::Level::error, "Message");
/// \endcode
///
///////////////////////////////////////////////////////////////////////////
class Logger {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // ErrorLevel
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Level of error to format the output
    ///
    /// The level should be used as followed:
    ///     - none: no extra output. Should be avoided
    ///     - note: user driven, configuration operations
    ///     - info: user driven, regularly scheduled operations
    ///     - trace: tracks potential bugs (disabled with NDEBUG)
    ///     - debug: (disabled with NDEBUG)
    ///     - warning: can potential become an error
    ///     - error: error that cannot be recovered but does not throw
    ///     - fatal: error that cannot be recovered, throws an exception
    ///     - fatalError: same as fatal
    ///
    /// \throws ::xrn::Exception fatal error
    ///
    ///////////////////////////////////////////////////////////////////////////
    enum Level {
        none = 0, // no extra output. Should be avoided
        success, // is successful
        note, // user driven (configuration operations)
        info, // user driven (regularly scheduled operations)
        trace, // tracks potential bugs (disabled with NDEBUG)
        debug, // (disabled with NDEBUG)
        warning, // can potential become an error
        error, // error that cannot be recovered but does not throw
        fatal, // error that cannot be recovered, throws an exception
        fatalError // same as fatal
    };



public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    Logger() = delete;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Log
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Logs using fmt
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename... Args
    > static void logImpl(
        ::std::string_view filepath,
        ::std::string_view functionName,
        ::std::size_t lineNumber,
        ::fmt::format_string<Args...> subformat,
        Args&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Logs using fmt
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename... Args
    > static void logImpl(
        ::std::string_view filepath,
        ::std::string_view functionName,
        ::std::size_t lineNumber,
        Logger::Level level,
        ::fmt::format_string<Args...> subformat,
        Args&&... args
    );



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Test
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Same as assert from <cassert>
    ///
    /// Prints successful tests if PRINT_DEBUG is defined
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename... Args
    > static void testImpl(
        bool condition,
        ::std::string_view filepath,
        ::std::string_view functionName,
        ::std::size_t lineNumber,
        ::fmt::format_string<Args...> subformat,
        Args&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename... Args
    > static void testImpl(
        bool condition,
        ::std::string_view filepath,
        ::std::string_view functionName,
        ::std::size_t lineNumber,
        Logger::Level level,
        ::fmt::format_string<Args...> subformat,
        Args&&... args
    );



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Helper
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Outputs the message with the right format
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename... Args
    > static void outputLog(
        ::std::string_view filepath,
        ::std::string_view functionName,
        ::std::size_t lineNumber,
        Logger::Level level,
        ::fmt::format_string<Args...> subformat,
        Args&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Test and outputs the message with the right format if needed
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename... Args
    > static void outputTest(
        bool condition,
        ::std::string_view filepath,
        ::std::string_view functionName,
        ::std::size_t lineNumber,
        Logger::Level level,
        ::fmt::format_string<Args...> subformat,
        Args&&... args
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Format date
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] static auto getDate()
        -> ::std::string;
};

} // namespace xrn



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Macros
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////
#define log(...) Logger::logImpl(__FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)

///////////////////////////////////////////////////////////////////////////
/// \brief Same as assert from <cassert>
///////////////////////////////////////////////////////////////////////////
#define test(condition, ...) Logger::testImpl(((condition)), __FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Header-implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
#include <xrn/Log/Logger.impl.hpp>
