///////////////////////////////////////////////////////////////////////////
// Precompilled headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <Model.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Helper
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

auto ::vksb::Model::Vertex::getBindingDescriptions()
    -> ::std::vector<::VkVertexInputBindingDescription>
{
    return { {
        .binding = 0,
        .stride = sizeof(::vksb::Model::Vertex),
        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX
    } };
}

auto ::vksb::Model::Vertex::getAttributeDescriptions()
    -> ::std::vector<::VkVertexInputAttributeDescription>
{
    return { {
        .location = 0,
        .binding = 0,
        .format = VK_FORMAT_R32G32_SFLOAT,
        .offset = 0,
    } };
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::vksb::Model::Model(
    ::vksb::Device& device,
    const ::std::vector<Model::Vertex>& vertices
)
    : m_device{ device }
    , m_vertexCount{ static_cast<::std::uint32_t>(vertices.size()) }
{
    if (m_vertexCount < 3) {
        throw ::std::runtime_error{ "Vertex count must be at least 3" };
    }
    auto bufferSize{ sizeof(vertices[0]) * static_cast<::std::uint32_t>(vertices.size()) };
    m_device.createBuffer(
        bufferSize,
        ::VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        ::VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
        m_vertexBuffer,
        m_vertexBufferMemory
    );
    void* pData;
    ::vkMapMemory(m_device.device(), m_vertexBufferMemory, 0, bufferSize, 0, &pData);
    ::memcpy(pData, vertices.data(), static_cast<::std::size_t>(bufferSize));
    ::vkUnmapMemory(m_device.device(), m_vertexBufferMemory);
}




///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rule of 5
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::vksb::Model::~Model()
{
    ::vkDestroyBuffer(m_device.device(), m_vertexBuffer, nullptr);
    ::vkFreeMemory(m_device.device(), m_vertexBufferMemory, nullptr);
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Basic
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::vksb::Model::bind(
    ::VkCommandBuffer commandBuffer
)
{
    ::VkBuffer buffers[] = { m_vertexBuffer };
    ::VkDeviceSize offsets[] = { 0 };
    ::vkCmdBindVertexBuffers(commandBuffer, 0, 1, buffers, offsets);
}

///////////////////////////////////////////////////////////////////////////
void ::vksb::Model::draw(
    ::VkCommandBuffer commandBuffer
)
{
    ::vkCmdDraw(commandBuffer, m_vertexCount, 1, 0, 0);
}
